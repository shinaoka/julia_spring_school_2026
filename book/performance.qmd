---
title: "性能評価と改善サイクル"
---

狙いは、計測の落とし穴を避けつつ、LLM と一緒に「改善→再計測→共有」を回すことである。

## JIT コンパイルのざっくりした説明

Julia は関数を **初めて呼び出したとき** に、渡された引数の型に合わせてネイティブコードへコンパイルする（JIT: Just-In-Time コンパイル）。つまり：

- **1 回目の呼び出し** はコンパイル込みなので遅い
- **2 回目以降** はコンパイル済みコードが再利用されるので速い
- 引数の **型が変わると** 、その型用に再コンパイルが走る

```julia
# 1 回目：コンパイル + 実行（遅い）
@time estimate_pi(10_000_000)
#  0.45 seconds (← コンパイル時間が含まれる)

# 2 回目：実行のみ（速い）
@time estimate_pi(10_000_000)
#  0.05 seconds
```

### LLM に聞いてみよう

**プロンプト例：**

```
Julia の JIT コンパイルを高校生に分かるように説明して。
「最初の 1 回が遅い理由」と「型に応じた最適化」がポイント。
```

## 「ダメな計測」と BenchmarkTools

### `@time` の問題点

`@time` で測ると、1 回目はコンパイル時間が混ざり、結果がバラつく。

```julia
# こう測るだけだと不十分
@time estimate_pi(10^7)   # コンパイル込み？実行だけ？
@time estimate_pi(10^7)   # GC のタイミングで揺れる
```

### BenchmarkTools で正しく測る

`BenchmarkTools.jl` の `@btime` は、内部で何度も繰り返し実行し、コンパイルを除いた安定した実行時間を報告する。

```julia
using BenchmarkTools

N = 10_000_000
@btime estimate_pi($N)   # $ でグローバル変数を補間
```

- **`$` 補間**：グローバル変数をそのまま渡すと、型が不安定（`Any` 型）になり遅くなる。`$` を付けるとローカル変数として扱われ、正しい性能が測れる
- `@btime` はデフォルトで複数回実行し、**最小値** を報告する

## サンプルリポジトリを動かす

講師が用意したサンプルリポジトリには、わざと遅く書いた `estimate_pi()` が入っている。これを clone して動かすこと。

### 1. fork して clone

1. GitHub で <https://github.com/shinaoka/julia_spring_school_2026_sample> を開く
2. 右上の **Fork** ボタンを押して、自分のアカウントにコピーを作る
3. fork した自分のリポジトリを clone する：

```sh
gh repo clone <自分のユーザ名>/julia_spring_school_2026_sample
cd julia_spring_school_2026_sample/topics/monte_carlo_pi
julia --project=. -e 'using Pkg; Pkg.instantiate()'
```

- 各トピックが独立した `Project.toml` を持つ構成
- fork した自分のリポなので、改善結果を commit & push できる

### 2. ベンチマークを実行

```sh
julia --project=. bench.jl
```

出力される実行時間を確認し、「これは速い？遅い？」を考えてみよう。

## LLM と一緒に高速化する

ここからが本題である。以下のサイクルを回す。

### 手順

1. **計測**：`bench.jl` を実行して現状の実行時間を記録する
2. **相談**：`estimate_pi.jl` のコードと計測結果を LLM に見せて、改善案をもらう
3. **修正と再計測**：提案を適用し、`bench.jl` を再実行して比較する
4. **記録**：改善できたら commit & push（fork した自分のリポに反映される）

### LLM への相談例

**プロンプト例：**

```
以下は Julia でモンテカルロ法を使って円周率を推定する関数です。
BenchmarkTools の @btime で測ったところ XX ms かかっています。

<estimate_pi.jl のコードを貼る>

このコードを高速化する方法を提案してください。
変更前後で結果が変わらないことも確認したいです。
```

### ポイント

- LLM の提案を **鵜呑みにしない**：必ず `@btime` で効果を確認する
- 改善の根拠を理解する：「なぜ速くなったか」を LLM に説明させる
- プロジェクト環境の中で作業する：`--project=.` を忘れずに

## まとめ

3 コマを通してできるようになったこと：

- LLM に Julia コードを書かせる・読ませる・説明させる
- 抽象化（関数・型・broadcast）の基本的な発想
- JIT と BenchmarkTools による性能評価の入り口
- プロジェクト環境と GitHub を使った、簡単な開発サイクル

今後への接続：より本格的な物理モデル（例：イジング模型など）やパッケージ開発への発展。

## 最後に残す問い

**いま測っているのは「プログラムのどの時間」？（コンパイル？実行？）**
